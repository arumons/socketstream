### Pub/Sub - イベントのブロードキャスティングとプライベートチャンネル

例：３で説明した `SS.publish.user()` メソッドの他に、ユーザにまとめてメッセージを送る方法が二つあります。

#### ブロードキャスティング

接続中の全クライアントに通知を行う場合（例えば、サーバーメンテナンスによるシステムダウンを全員に通知する場合）、broadcast メソッドを使います。

``` coffee-script
SS.publish.broadcast('flash', {type: 'notification', message: 'お知らせ: サービスは10分間ご利用できません。'})
```

このイベントをブラウザで受け取るには下記のように書きます：

``` coffee-script
SS.events.on 'flash', (msg) ->
  alert(msg.message)
```

#### プライベートチャンネル
    
複数の部屋があるチャットアプリを作るなら、メッセージを特定のグループにのみ通知したいこともあるでしょう。まさにそのための機能としてプライベートチャンネルが用意されています。

シンタックスは先ほど紹介したメソッドと似ています。チャンネル名（もしくはチャンネル名の配列）を第一引数に与えてください。


``` coffee-script
SS.publish.channel(['disney', 'kids'], 'newMessage', {from: 'mickymouse', message: 'Tom をどこかで見なかったかい？'})
```

ブラウザでこれらのイベントをブロードキャストと同様に受け取ってください。イベントがチャンネルに対して送られると、第二引数にチャンネル名が渡されます：

``` coffee-script
SS.events.on 'newMessage', (msg, channel_name) ->
  console.log "#{channel_name} チャンネルへ送られたメッセージが続きます:", msg
```
 
★クライアントは下記のコマンドで無制限のチャンネルを登録できます（このコマンドは /app/server 内でのみ呼び出せます）。

``` coffee-script
  @session.channel.subscribe('disney')        # 補足: 複数のチャンネルを配列にまとめて渡せます。
    
  @session.channel.unsubscribe('kids')        # 補足: 複数のチャンネルを配列にまとめて渡せます。

  @session.channel.unsubscribeAll()           # 全ての購読を取り消します（ログアウト時に便利です）。
    
  @session.channel.list()                     # 現在購読中のチャンネル一覧を表示します。
```

#### クライアント毎（ブラウザのタブ）

__警告__: このメソッドは将来変更されるでしょう_

複数のタブは同じ @session.id を持ち、同じプライベートチャンネルを購読します。通常はこれでも問題ありませんが、クライアント毎（ブラウザのタブ毎）にメッセージを送りたいこともあるでしょう。下記のようにすることで要求を満たすことができます。

`` coffee-script
SS.publish.socket('254987654324567', 'justForMe', 'あるタブ専用です')
```

現在の socket_id を知るにはプロパティを参照します:

``` coffee-script
SS.socket.socket.sessionid       # クライアントサイド
@request.socket_id               # サーバーサイド （/app/server メソッドから）
```

socket_id はページをリフレッシュすることで変更されます。クライアントにプライベートチャンネルを割り当て、可能な限りそれを使うようにすると良いでしょう。

**Notes**

1. 特定のメソッド（例：`subscribe`）はオプショナルなコールバック関数を引数に取ります。高速な結合テストを書くのに役立つでしょう。

2. 存在しないチャンネル名を指定すると、自動的に作成されます。チャンネル名は JavaScript のオブジェクトキーとして有効であればどんな文字列でも使用できます。クライアントが切断して別のサーバーインスタンスへ再接続した場合でも以前のセッションIDを保持している限り、同じチャンネルへ再登録が行われます。これらのコマンドを使う際はエラーを必ずハンドルしてください。

3. SocketStream Pub/Sub システムはスケールアウトと高スループットを完全に念頭においてデザインされています。'broadcast' と 'channnel' コマンドは全ての SocketStream サーバー間で自動的にロードバランスされます。

4. メッセージがどこかに格納されたり、ログに残ることはありません。クライアント／ユーザーがオフラインだとメッセージはキューに残ることなく失われます。リアルタイムなチャットアプリを作るなら、メッセージを送る前にデータベース（もしくはメッセージングサーバー）に保存することをオススメします。
