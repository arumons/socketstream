*> [name]: [comment] <* でコメントを入れていきます。 # TODO 最終的には消す

## 0.1 から 0.2 への変更点


### イントロダクション

2011年6月23日、わたしたちは初の100%リアルタイムなフルスタックwebフレームワークを公開しました。今まさにバージョン0.2.0 をリリースできることを喜んでいます。SocketStream は複数のサーバでリクエストを分散処理させるためにデザインされた初のリアルタイムwebフレームワークなのです。 *> bekkou: 2回言っているので大事なことだと思い、最後は "なのです" で強調している感じにしました <* *> arumons: 100%の前にはスペースないほうが好みかなあ ここのローンチって＝公開ってことだね <*

0.2.0 では、わたしたち開発チームの目標である「高いトラフィックをさばけ、スケールアウト可能なwebアプリケーションプラットフォームの提供」に近づきました。もちろん開発者のみなさんが求めていた機能を実現したとともに、ちょっとしたサプライズな機能も追加しています。 *> arumons: 水平方向にスケール　＝　スケールアウト可能で置き換えてOKだと思う <*


### 分散スケーリング

0.2 ではアーキテクチャが再構成され、フロントエンド（クライアントアセット・HTTP API の提供や websockets を扱います）は完全にバックエンド（データベース／Redis のやりとりやリクエストの処理を担当します）と独立するようになりました。リクエストは内部RPCを呼び出すことによってフロントエンドからバックエンドへと非同期に転送されます。

アーキテクチャの分離によってコードが整理され、テストやベンチマークによる測定が容易になりました。さらに重要なポイントは、高速で低レイテンシな [ZeroMQ](http://www.zeromq.org) を使うことでフロントエンドとバックエンドサーバをそれぞれ独立して立ち上げられるようになったことです。ZeroMQ のインストール方法は `socketstream help` コマンドを実行することで確認できます。

websocket をサポートするようになった [Mongrel2](http://mongrel2.org) （これもまた ZeroMQ 上に構築されています）やバックエンドリクエストハンドラを異なる言語・プラットフォーム（例: [Twitter's Finagle](http://twitter.github.com/finagle)）で書くことは今後興味深い選択肢になるでしょう。こういった分野に興味がありましたら是非つかってみてください。

話が脱線しかけましたがスケーリングに戻りましょう...

バージョン0.1ではすべての処理をシングルスレッドにて行うよう、制限されていました。しかし0.2ではマルチコアCPUや複数のマシン上にて動作する複数のバックエンドサーバーをサポートしています。いつでもトラフィックに応じて水平スケールアップを行えるようになっています。

複数のバックエンドサーバーをCPUをフルに使うタスク（例えばリクエストごとに1000のランダムな文字列を算出するなど）やマルチコアCPUのリソースを乱用するようなタスクに追加した場合、ベンチマークは線形に近い形になるでしょう。これらのバックエンドサーバーはゼロコンフィグレーションで追加や削除が行えます。そのため新しいEC2インスタンスはAWSオートスケーリングを使うことで自動的に起動と停止を行うことができます。

`socketstream server` によってサーバーを今まで通り立ち上げる方法は変わりません。しかしあなたの方で準備が整ったら、私たちはスケールアップするための多数の方法を紹介できるでしょう。

詳細について確認するには、スケーリングについてのセクション /doc/guide/ja/deploying/scaling.md を参照してください。

我々は0.2をクラウドコンピューティングを念頭においてデザインされたスケーラブルなワールドクラスの製品の第一歩として捉えています。
ZeroMQは現時点でベストの選択だと我々は考えています。我々の内部RPCレイヤは複数のトランスポートをサポートしており、帰結として将来異なるテクノロジーを実装することが可能になっています。


### ミドルウェアとして Connect を使用

バージョン 0.2 では HTTP ミドルウェアとして Connect を使用しています。これによって豊富なサードパーティ製のミドルウェアや、または自身で書いたミドルウェアををフックさせることができます。

★ またテストやドキュメント化はしていませんが、Connect を使うことで全体のリクエストオブジェクトを /config/http.coffee に露出するのと同様にCOnnect Auth を利用できることを意味します。POST ヘッダにアクセスしたくなるでしょう。

/config/http.coffee ファイルは現在オプショナルです。もし、このファイルを過去に変更したことがあるのなら、ファイルを0.2のプロジェクトにコピーする必要があります。そうしない限り、既存のカスタムミドルウェアは無視されるでしょう。


### Socket.IO の新バージョン

Socket.IO の最新バージョンである0.8は古いブラウザとFirefox 6やChrome 14といった最新のwebsocket標準を実装しているブラウザの両方に対して互換性を持つよう統合されています。これによって client/server のコード全体が整理されました。

★ Socket.IO の最新バージョンではSocketStream 0.1で使われていた Socket.IO のバージョンと少し振る舞いが異なります。disconnects/reconnects が即座には呼び出されないことに気がつくでしょう。その代わりブラウザはサーバーから応答が帰ってくるのを待ちます。Socket.IO の設定は /app/config.coffee にて変更できます。 詳細は /doc/guide/ja/developing/environments_and_configuration.md を参照してください。

この素晴らしいライブラリを更に改善してくれた Guillermo Rauch に再度感謝します。


### サーバーサイドイベントバインディング

0.1ではクライアントの切断時、サーバーサイドにて特定の振る舞い（例：データベースのクリーンアップコード、スクリーンからのアバター画像の削除）
を行おうと思ったら、そのためのコードを /app/server/app.coffee に配置し、各セッション毎にそれが確実に呼ばれるようにする必要がありました。
これは面倒な作業でした。

0.2ではサーバーサイドイベントという機能によってもっと簡単になっています。/config/events.coffee（もしくは event.js ）にイベントに対するコードを書きます。このファイルは新しいプロジェクトを生成したときにデフォルトで作成され、すべての使用可能なイベントがコメントアウトされた状態で記述されています。

現在、クライアントの初期接続時やハートビードが送られた時、もしくは切断時（ブラウザを閉じたときや回線がタイムアウトした時など）のタイミングで実行されるサーバーサイドのコードを書けるようになっています。どんなリクエストでも同様の方法でこれらのイベントは各バックエンドサーバーに自動的にロードバランシングされるようになっています。


### 新規 socketstream ベンチマークコマンド

私たちは ZeroMQ 支援によるルーターとバンクエンドサーバーに対してストレステストを行うため、幾つかのベンチマークを追加しました。
これらのコマンドは異なるスケーリングテクノロジーや設定を評価するにあたってかけがえのないものです。

将来はフロントエンドやユーザー自身のアプリケーションコードを計測するためのベンチマークが追加されるでしょう。


### Plug ソケット（まだ実験中です）

ZeroMQ によって0.2では非常にワクワクする機能がもたらされました。

★ Plug ソケットは SocketStream に既存のアプリや外部サーバーと高速で通信するための手段を提供します。これはやってきたデータをCで書かれたゲームサーバーや、Erlangで書かれたメッセージサーバー、Javaで書かれた金融システムに送るのにうってつけの機能です。実際、20を超える言語によって書かれている ZeroMQ バインディングによって Plug Sockets を外部とやりとりするために使うことができます。

★ 近い将来、Plug Sockets を既存の Rails プロジェクトに対しての新しいリアルタイムwebインタフェースを簡単に作るためにすることができるかもしれません。Ruby で書かれた既存のモデルやビジネスロジック、spcecsを維持している間。

我々が内部で使っているJSON RPC 非同期リクエストハンドラ、もしくはスピードを最大限に発揮するために自身で書いたバイナリレベルのプロトコルのどちらを使うかを選ぶこともできるでしょう。どちらを選ぶかはあなた自身です。

詳細は /doc/guide/en/optional_modules/plug_sockets.md を参照してください。


### 自動リロード

0.1では開発モードにてクライアントサイドコードへの変更が起こった場合、サーバーの再起動無しにブラウザへ変更が反映されていました。

0.2では、これを更に推し進めました。ZeroMQ がインストールされているなら（インストール方法については `socketstream help` を参照してください）、バックエンドで動作するプロセスはプロセスマネージャによって生成されます。サーバーサイドコードに変更を加えると（development モードの場合）自動的に子プロセスを終了させ、新しいプロセスを生成します。

我々はまた、ファイルが変更された場合にクライアント側のウィンドウ／タブを自動リロードも実験しています。今のところ、この機能は /lib/client、/lib/css、/app/server 配下のファイルに対して働きます。
この新機能はまだ開発中のため、デフォルトではOFFになっていますが、 SS.config.client.auto_reload を true にすることで有効にすることができます。注意：変更は Unix／Linux では即座に検知されますが、OS Xでは Node.jsがファイルへの変更を検知する仕組みの都合上、若干ディレイがあります。願わくば将来この問題が改善することを望みます。


### その他の変更点

* SS.server メソッドは複数の引数を取ることができるようになりました（但し、HTTP API との互換性を完全に保つには全ての引数をオブジェクトにつめて最初の引数に渡す必要があります）
* 新しい @request オブジェクトは /app/server 内のメソッドからアクセスできます。（HTTP API として呼び出された場合、HTTP POST データを含みます）
* Node.js のデバッガをサポートするようになりました（`socketstream debug server` とタイプするだけです）。全てのコマンドをデバッグできます
* /static ディレクトリは削除されました。デフォルトではブラウザの互換性チェックは /app/views/incompatible.jade（もしくは.html）ファイルを見て行うようになっています。（config にてファイルを変更できます）
* exports.authenticate = true は現在バックエンドサーバーとリクエストハンドラによってリクエストの発信元に関係なく常に有効になっています。
* SS.config.redis.password は現在オプションで提供されます。
★* http://en.wikipedia.org/wiki/JSON-RPC にて
* Improved HTTP API when specifying requests with .json Now more closely aligned with http://en.wikipedia.org/wiki/JSON-RPC
* NPM 1.x によって正確なバージョンが自動的にロードされるようになったため、 SS.libs は取り除かれました
* `session`、`request`、`user`といった予約された変数名は SS.config.reserved_vars の値を変更することで、変更できるようになりました
* /app/server の呼び出しロジックの性能が向上しました
* /vendor ディレクトリは削除されました。代わりに /node_modules を使用してください
* /app/server にて共有されるコードを使うには SS.require() を呼び出します。これは /lib/server 配下からファイルを検索します
* ユーザーへのイベントの発信はチャンネルと同じ仕組みで動作します - 複数回メッセージを発信する際により効率的になりました 
* イベントを発信する際、パラメータは必須ではなくなりました
* Jasmine による少数のspecによるテスト。これらは現在外部プロジェクトとして実装されています
* README 内にあった多くのセクションを /doc/guide へ移動させました。 移動に協力してくれた CC Maco Young に感謝です

8月7日にリリースされた0.2のプレビュー版から多くの変更が加えられています。HISTORY.md をチェックしてください


### 0.1.0 からのAPIの変更点

幾つかの変更が SocketStream のデベロッパAPIに加えられています。0.2でもほとんどの機能は0.1との互換性を保っています。例外としてはHTTP Basic 認証です。来るべき0.3にて我々がサーバーサイドモデルによって認証方法を統合する最適な方法を理解したときに、この機能は戻るでしょう

現在のセッションを取得する方法として @session と @getSession(cb) コールバックを使う方法を試しましたが、我々は @session を使う方をお勧めします。
0.2ではセッションの詳細は Redis に格納され、不必要な Redis アクセスを避けるためにフロントエンドサーバーにキャッシュされるようになります（バックエンドサーバーには内部RPC転送にて送られます）

続けて、HTTP ミドルウェアを何も使っていないのなら /config/http.coffee ファイルを削除、もしくは新しいフォーマットにアップグレードする必要があるかもしれません（新規プロジェクトに含まれているサンプルを見てみてください）


### 開発を手伝う方法

たくさんの人が 0.1 へのpull request を送ってくれました。

★ 将来の新機能のため、安定した基盤の提供と新しい分散アーキテクチャのサポートを行うためのコードの再編成は必要でした。それは片付いたので、コードをもっと効率的にしたり、新しい機能を追加することは自由です。
It was necessary to reorganize the code to support the new distributed architecture and provide a stable foundation for future features. Now that's over with, feel free to take a section of code and work on it to make it more efficient - or implement a new feature (with the obvious caveat that not all features should find their way into the core).

シンプルでより効率的な結果になるのなら、大きな変更を加えることを躊躇しないでください。


## 次に向かう方向

どうしてこんなにもスケーラビリティを強調するのだろうと思ったかもしれません。私たちは SocketStream を次のプロジェクトに取り組むためにスケールできるようにする必要がありました。

★ www.socketstream.org に配置する SocketStream のためのリアルタイムWebサイトに向けて、我々はビッグアイディアを持っています。それはパブリックなWebサイトでの新しい ZeroMQ のスケーリング技術のテストになるでしょう。 一度リンクが Hacker News でヒットすると役にたちます（意味不明）

★　結論として、我々はバージョン0.3に向けて活動を始めています。これはモデルの実装（クライアントとサーバーサイド）、Backbone.js の統合（これは簡単にできますが、オプショナルです）、そして数多くの新機能を追加するためにクライアントサイドのアセットマネージャの書き直しを含んでいます。これらについてのヘルプが可能でしたら是非協力をお願いします。

0.3移行に向けてのディスカッションは次のURLで見ることができます:http://groups.google.com/group/socketstream/browse_thread/thread/b6f580691151b038


### 考え

徐々に SocketStream は２つの存在に徐々に変化していることが明らかになってきています。一つはリアルタイムフルスタックフレームワーク、２つ目は（まだ発展の余地がありますが）高速な分散リアルタイムホスティングフレームワークです。これらはシンプルかつ簡単に複数のサーバーにまたがった どんな SocketStream プロジェクトディレクトリにも最小限の設定で提供されます。

★ これらの両方とも非常に興味深いプロジェクトですが、両方を合わせることで、非常に協力かつ魅力的なプラットフォームになる可能性を秘めています。年末と2012年にかけて計画しているプロジェクトのいくつかでこれらを更に

将来の計画としては、分散ホスティング用のコンポーネントを分割した `socketstream-server` プロジェクト／NPMにすることがあります。これは製品用のサーバーによってのみ必要とされます。これはバーチャルホスティング（多くのwebサイトを一つのサーバーにて運用）したり、大量のトラフィックを処理するためにより多くのサーバーを簡単に起動できるようになる可能性を秘めています。皆さんのコメントや考えを歓迎しています。
一緒に進化を見届けましょう...


### そして最後に

Google Group や IRC チャンネルにて機能の提案やアイディアに貢献してくれた多くの方々に感謝します。今後もよろしくお願いします :)
